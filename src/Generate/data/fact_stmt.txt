        Fact(IsPermutation(newOrder), $"The new ordering is not a permutation");
        Fact(to >= from, $"`to` must be larger than `from`");
        Fact(to >= from, $"`to` must be larger than `from`");
        Fact(to - from <= 0x07FFFFFFFFFFFFFFEL, $"different between `to` and `from` is too large");
        Fact(bits >= 0 and bits <= 63, $"`bits` must be between 0 and 63 {2^bits}");
        Fact(number >= 0 and number <= max, $"`number` must be between 0 and 2^{bits} - 1, but was {number}.");
        Fact(Length(bits) < 64, $"`Length(bits)` must be less than 64, but was {Length(bits)}.");
        Fact(IsPermutation(perm), "perm must be a permutation");
        EqualityFactI(Length(perm), 2^Length(qubits!), $"Length of perm must be {2^Length(qubits!)}");
        Fact(IsPermutation(variableOrder), "variableOrder must be a permutation");
        EqualityFactI(Length(variableOrder), Length(qubits!), $"Length of variableOrder must be {Length(qubits!)}");
        Fact(a >= 0 and a < 2^n, $"Argument a must be value from 0 to {2^n - 1}");
        Fact(b >= 0 and b < 2^n, $"Argument b must be value from 0 to {2^n - 1}");
        Fact(IsPermutation(perm), "perm must be a permutation");
        EqualityFactI(Length(perm), 2^Length(qubits!), $"Length of perm must be {2^Length(qubits!)}");
            Fact(func >= 0L and func < maxValue, $"Argument func must be value from 0 to {maxValue}");
            Fact(func >= 0L and func < maxValue, $"Argument func must be value from 0 to {maxValue}");
            Fact(func >= 0L and func < maxValue, $"Argument func must be value from 0 to {maxValue}");
        SquareMatrixFact(unitary);
        EqualityFactI(Length(unitary), 1 <<< Length(qubits!),            "Matrix size is not consistent with register length.");
        EqualityFact1C(actual, Identity1C(), message);
        Fact(targetError > 0.0, "targetError must be positive");
        Fact(nCoefficients > 0, "nCoefficients must be positive");
        Fact(bitsPrecision <= 31, $"Bits of precision {bitsPrecision} unsupported. Max is 31.");
        Fact(nCoefficients > 1, "Cannot prepare state with less than 2 coefficients.");
        Fact(oneNorm != 0.0, "State must have at least one coefficient > 0");
        Fact(modulus > 0, $"`modulus` must be positive");
        Fact(modulus > 0L, $"`modulus` must be positive");
        Fact(power >= 0, $"`power` must be non-negative");
        Fact(modulus > 0, $"`modulus` must be positive");
        Fact(expBase > 0, $"`expBase` must be positive");
        Fact(power >= 0L, $"`power` must be non-negative");
        Fact(modulus > 0L, $"`modulus` must be positive");
        Fact(expBase > 0L, $"`expBase` must be positive");
        Fact(denominatorBound > 0, $"Denominator bound must be positive");
        Fact(denominatorBound > 0L, $"Denominator bound must be positive");
        EqualityFactI(gcd, 1, $"`a` and `modulus` must be co-prime");
        EqualityFactL(gcd, 1L, $"`a` and `modulus` must be co-prime");
        Fact(a >= 0, $"`a` must be non-negative");
        Fact(a >= 0L, $"`a` must be non-negative");
        Fact(n >= 0, "The factorial is not defined for negative inputs.");
        Fact(n < 21, "The largest factorial that be stored as an Int is 20!. Use FactorialL or ApproximateFactorial.");
        Fact(n >= 0, "The factorial is not defined for negative inputs.");
        Fact(n < 170, "The largest approximate factorial that be stored as an Double is 169!. Use FactorialL.");
        Fact(x > 0.0, "Î“(x) not defined for x <= 0.");
        EqualityWithinToleranceFact(actual, expected, 1e-10);
        Ignore(Mapped(EqualityFactB(_, _, message), Zipped(actual, expected)));
        Ignore(Mapped(EqualityFactI(_, _, message), Zipped(actual, expected)));
        EqualityFactI(            nQubits, Length(register) + 1,            "Target register must have one more qubit."        );
        Fact(nQubits > 0, $"`Length(qs)` must be least 1");
        Fact(a > 0 and a <= nQubits, $"`a` must be positive and less than `Length(qs)`");
        EqualityFactI(Length(ordering), Length(register), "The new ordering has an incorrect number of elements");
            Fact(numControls >= 1, "Length of controls must be at least 1");
            Fact(numControls >= 1, $"Length of controls must be at least 1");
        EqualityFactI(Length(controls), Length(targets) + 1, $"Length(controls) must be equal to Length(target) + 1");
        Fact(Length(controls) >= 2, $"The operation is not defined for less than 2 controls");
        EqualityFactB(numberOfQubitsToFirstArgument >= 0, true, $"numberOfQubitsToFirstArgument must be non-negative");
        EqualityFactB(Length(target) >= numberOfQubitsToFirstArgument, true, $"Length(target) must greater or equal to numberOfQubitsToFirstArgument");
            EqualityFactB(numberOfQubitsToFirstArgument >= 0, true, $"numberOfQubitsToFirstArgument must be non-negative");
            EqualityFactB(Length(target) >= numberOfQubitsToFirstArgument, true, $"Length(target) must greater or equal to numberOfQubitsToFirstArgument");
            EqualityFactB(numberOfQubitsToFirstArgument >= 0, true, $"numberOfQubitsToFirstArgument must be non-negative");
            EqualityFactB(Length(target) >= numberOfQubitsToFirstArgument, true, $"Length(target) must greater or equal to numberOfQubitsToFirstArgument");
            EqualityFactB(numberOfQubitsToFirstArgument >= 0, true, $"numberOfQubitsToFirstArgument must be non-negative");
            EqualityFactB(Length(target) >= numberOfQubitsToFirstArgument, true, $"Length(target) must greater or equal to numberOfQubitsToFirstArgument");
        Fact(nQueries % 2 == 1, "nQueries must be odd");
        EqualityFactI(Length(phases::AboutStart), Length(phases::AboutTarget), "number of phases about start and target state must be equal");
            EqualityFactI(                nQubits, Length(ys!),                "Input registers must have the same number of qubits."            );
        EqualityFactI(            nQubits, Length(ys!),            "Input registers must have the same number of qubits."        );
        EqualityFactI(            nQubits, Length(ys!),            "Input registers must have the same number of qubits."        );
        EqualityFactB(            nQubits == Length(ys!), true,            "Input registers must have the same number of qubits." );
            EqualityFactI(                nQubits, Length(ys!),                "Input registers must have the same number of qubits."            );
            Fact(modulus <= 2 ^ (Length(target!) - 1), $"`multiplier` must be big enough to fit integers modulo `modulus`" + $"with highest bit set to 0");
        Fact(modulus <= 2 ^ (Length(phaseSummand!) - 1), $"`multiplicand` must be big enough to fit integers modulo `modulus`" + $"with highest bit set to 0");
        Fact(constMultiplier >= 0 and constMultiplier < modulus, $"`constMultiplier` must be between 0 and `modulus`-1");
        EqualityFactB(0 <= constMultiplier and constMultiplier < modulus, true, $"`constMultiplier` must be between 0 and `modulus`");
        EqualityFactB(modulus <= 2 ^ Length(multiplicand!), true, $"`multiplicand` must be big enough to fit integers modulo `modulus`");
        EqualityFactB(IsCoprimeI(constMultiplier, modulus), true, $"`constMultiplier` and `modulus` must be co-prime");
            IdenticalFormatFactFxP([fpx, result]);
            IdenticalFormatFactFxP([fpx, result]);
            IdenticalFormatFactFxP([fpx, result]);
        IdenticalFormatFactFxP([fp1, fp2]);
            Fact(p + pRes - 1 + n >= Length(rs), "Output register is too wide.");
        IdenticalPointPosFactFxP([fp1, fp2]);
            IdenticalFormatFactFxP([fp1, fp2, result]);
            IdenticalFormatFactFxP([fp, result]);
        Fact(position > 0, "Point position must be greater than zero.");
            EqualityFactI(fp::IntegerBits, position,                "FixedPoint numbers must have identical binary point position.");
            EqualityFactI(Length(fp::Register), n,                "FixedPoint numbers must have identical number of qubits.");
        Fact(position > 0, "Point position must be greater than zero.");
            EqualityFactI(Length(fp::Register) - fp::IntegerBits, n - position,                "FixedPoint numbers must have identical point alignment.");
            EqualityFactI(n, Length(ys!), "Integer division requires                           equally-sized registers ys and result.");
            EqualityFactI(n, Length(xs!), "Integer division                            requires an n-bit dividend registers.");
            EqualityFactI(Length(result!), 2*n,                          "Result register must contain 2n qubits.");
            EqualityFactI(na + nb, Length(result!), "Integer multiplication requires a register as long as both input registers added");
            EqualityFactI(na + nb, Length(result!), "Integer multiplication requires a register as long as both input registers added");
            EqualityFactI(2 * n, Length(result!), "Integer multiplication requires a 2n-bit result registers.");
        Fact(IsFinite(d), message);
        Fact(max >= min, $"Max must be greater than or equal to min, but {max} < {min}.");
        Fact(max >= min, $"Max must be greater than or equal to min, but {max} < {min}.");
            Fact(prob >= 0.0, "Probabilities must be positive.");
